def distribute(board, starting_pit, current_player):
    """
    name - Akbar Sajjad
    Distribute the stones one by one into the pits, skipping over the opponents pit
    
    Arguments:
        board: list (sample board) - [4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 4, 4, 0]
            p1 pits - indices 0-5 | p1 storage - index 6
            p2 pits - indices 7-12 | p1 storage - index 13    
        starting pit: int - index of the chosen pit to distribute stones from 
        current_player: str - the current player ("p1" or "p2")
    
    Returns:
        board: list - updated board after stones have been distributed
        last_pit: int - index of the pit where the last stone was placed
    """
    #determining the starting pit to start distribution
    if board[starting_pit] > 0:
        current_stonecount = board[starting_pit]
        board[starting_pit] = 0
    else:
        print("You must pick a board that has at least 1 stone and is not"\
            "yours or your opponents scoring pit")
        return board
    
    # where to begin dropping stones
    droppoint = (starting_pit + 1) % 14
 
    # skipping pits logic based on current player
    skippedpit = 13 if current_player == "p1" else 6
        
    
    #distribution iteration
    for stones in range(current_stonecount):
        while droppoint == skippedpit:
            droppoint = (droppoint + 1) % 14 
        
        #place stones
        board[droppoint] += 1
        last_pit = droppoint
        droppoint = (droppoint + 1) % 14 
    
    #return updated board and the last pit the stone was placed
    return board, last_pit


def capture(board, last_pit, player):
    """Apply the capturing aspect of Mancala.
    
    board: ints representing stones in pits
    last_pit: index of last pit marble was placed
    player: 1 or 2
    
    Returns: updated board
    """
    #set pit and store status
    #p1 first pit is 0, p2 first pit is 7
    p1_side = range(0,6)
    p2_side = range(7,13)
    
    #p1 store is 6, p2 store would be 13
    p1_store = 6
    p2_store = 13
    
    #need to find out position of last marble using player
    #1 is player 1 and 2 is player 2
    if player == 1:
        #my_side is the side of the current player
        my_side = p1_side
        #store is the store of the current player
        store = p1_store #would be 6 in this case
        parallel = 12 - last_pit #calc parallel side
    else: #repeat for player 2
        my_side = p2_side
        store = p2_store
        parallel = 12 - last_pit
    
    #check if current pit is empty AND is on current player side
    if last_pit in my_side and board[last_pit] == 1:
        
        #initialize var to take marbles from parallel side
        take_parallel = board[parallel]
        
        #capture marbles from take_parallel
        board[store] += 1 + take_parallel #use += 1 to include player's marble
        
        #empty the board at the last pit and the parallel pit
        #marbels have been taken and added to player store
        board[last_pit] = 0
        board[parallel] = 0

    return board


def check_turn(last_index, player1, player2): 
    """Determines if the current player gets another turn or if the turn switches.

    Args:
        last_index (int): the index of the pit where the last marble landed
        player1 (Player): the player who just had a turn
        player2 (Player): the player who is playing against player1

    Side effects: 
        - Prints whether it is player1 or player2's turn
    """
    player_score_pit = get_pit_index(player1)

    #if player1 landed in their score pit, they get another turn
    if last_index == player_score_pit:
        set_turn(player1, True)
        set_turn(player2, False)
        print(f"{player1.name} gets another turn!")

    #if player1 does not land in their score pit, it is player2's turn
    else:
        set_turn(player1, False)
        set_turn(player2, True)
        print(f"{player2.name}'s turn!")

def end_game_and_final_score(board, p1_side, p2_side): #Theo's Function
    """Checks the pebbles in each pit and places remaining pebbles in a player's,
    then compares score to return a winner or draw if the scores are equal


    Args:
        board (list of ints): A representation of the board using list of numebrs
        p1_side (list): A list of numbers representing Player 1's side of the board
        p2_side (list): A list of numbers representing Player 2's side of the board

    Returns:
        final_scores (Dict): The players and their scores
        game_end (Bool): Whether the game has eneded or not (True if game has ended. False If not)
        winner (Str): The name of the winner as a string
        board (list): An updated board after remeining pebbles have been added
        
    """
    game_end = False 
    final_scores = {} # Creates an empty dictonary to store the player's score{Player:Score}
    
    # For each pit on player 1's side check to see if all the pits are empty 
    # If they are then the game should end
    for pit in p1_side:
        if all(board[pit] == 0):
            game_end = True
            
            # For each pit on Player 2's side add all the leftover the pebbles 
            for pit in p2_side:
                remaining_pebbles = sum(board[pit])
                
                # Remove the pebbles from the pits after the remainder is recorded
                # Add the total leftover pebbles to the Player 2's store
                for pit in p2_side: 
                    board[pit] = 0
                board[p2_store] += remaining_pebbles
                
    for pit in p1_side
        if all(board[pit] == 0):
            game_end = True
            for pit in p1_side:
                remaining_pebbles = sum(board[pit])
                for pit in p1_side: #Removes pebbles after the remainder recorded
                    board[pit] = 0
                board[p1_store] += remaining_pebbles
                
    # Create players as dictionary keys with the scores as their values
    final_scores["Player 1"], final_scores["Player 2"] = board[p1_store], board[p2_store]
    
    # Compare the scores. The player with with higher number is the winner
    # If the scores are eqaual then the game is a draw
    if final_scores["Player 1"] > final_scores["Player 2"]:
        winner = "Player 1"
    elif final_scores["Player 2"] > final_scores["Player 1"]:
        winner = "Player2"
    else:
        winner = "Draw"
        
    return final_scores,winner, game_end, board
        