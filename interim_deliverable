def distribute(board, starting_pit, current_player):
    """
    name - Akbar Sajjad
    Distribute the stones one by one into the pits, skipping over the opponents pit
    
    Arguments:
        board: list (sample board) - [4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 4, 4, 0]
            p1 pits - indices 0-5 | p1 storage - index 6
            p2 pits - indices 7-12 | p1 storage - index 13    
        starting pit: int - index of the chosen pit to distribute stones from 
        current_player: str - the current player ("p1" or "p2")
    
    Returns:
        board: list - updated board after stones have been distributed
        last_pit: int - index of the pit where the last stone was placed
    """
    #determining the starting pit to start distribution
    if board[starting_pit] > 0:
        current_stonecount = board[starting_pit]
        board[starting_pit] = 0
    else:
        print("You must pick a board that has at least 1 stone and is not"\
            "yours or your opponents scoring pit")
        return board
    
    # where to begin dropping stones
    droppoint = (starting_pit + 1) % 14
 
    # skipping pits logic based on current player
    skippedpit = 13 if current_player == "p1" else 6
        
    
    #distribution iteration
    for stones in range(current_stonecount):
        while droppoint == skippedpit:
            droppoint = (droppoint + 1) % 14 
        
        #place stones
        board[droppoint] += 1
        last_pit = droppoint
        droppoint = (droppoint + 1) % 14 
    
    #return updated board and the last pit the stone was placed
    return board, last_pit


def capture(board, last_pit, player):
    """Apply the capturing aspect of Mancala.
    
    board: ints representing stones in pits
    last_pit: index of last pit marble was placed
    player: 1 or 2
    
    Returns: updated board
    """
    #set pit and store status
    #p1 first pit is 0, p2 first pit is 7
    p1_side = range(0,6)
    p2_side = range(7,13)
    
    #p1 store is 6, p2 store would be 13
    p1_store = 6
    p2_store = 13
    
    #need to find out position of last marble using player
    #1 is player 1 and 2 is player 2
    if player == 1:
        #my_side is the side of the current player
        my_side = p1_side
        #store is the store of the current player
        store = p1_store #would be 6 in this case
        parallel = 12 - last_pit #calc parallel side
    else: #repeat for player 2
        my_side = p2_side
        store = p2_store
        parallel = 12 - last_pit
    
    #check if current pit is empty AND is on current player side
    if last_pit in my_side and board[last_pit] == 1:
        
        #initialize var to take marbles from parallel side
        take_parallel = board[parallel]
        
        #capture marbles from take_parallel
        board[store] += 1 + take_parallel #use += 1 to include player's marble
        
        #empty the board at the last pit and the parallel pit
        #marbels have been taken and added to player store
        board[last_pit] = 0
        board[parallel] = 0

    return board


def check_turn(last_index, player1, player2): 
    """
    Determines if the current player gets another turn or if the turn switches.

    Args:
    
        last_index (int): the index of the pit where the last marble landed
        
        player1 (Player): the player who just had a turn
        
        player2 (Player): the player who is playing against player1

    Side effects: 
        Prints whether it is player1 or player2's turn
    """
    player_score_pit = get_pit_index(player1)

    #if player1 landed in their score pit, they get another turn
    if last_index == player_score_pit:
        set_turn(player1, True)
        set_turn(player2, False)
        print(f"{player1.name} gets another turn!")

    #if player1 does not land in their score pit, it is player2's turn
    else:
        set_turn(player1, False)
        set_turn(player2, True)
        print(f"{player2.name}'s turn!")


    return final_scores, winner, game_end, board

def Check_game_end(board, p1_side, p2_side, p1_store, p2_store):
    """ 
    End game if one side of the board is empty or when one player has more than
    half the pebbles in their store.

    Args:
    
        board (list): The game board represented by as a list of integers.
        Each index represents a pit with the number being the amount of pebbles
        or stones in each pit  
        
        p1_side (int): The indices of the pit's on Player 1's side (range: 0-6)
        
        p2_side (int): The indices of the pit's on Player 2's side (range: 7-13)
        
        p1_store (int): Player 1's score pit  that contains captured pebbles (index: 6)
        
        p2_store (int): Player 2's score pit  that contains captured pebbles (index: 13)

    Returns:
    
        Bool: True if the game has ended, False if the game has not ended.
    """
    total_stones = sum(board)
    
    if board[p1_store] > total_stones // 2 or board[p2_store] > total_stones // 2:
        return True
    
    
    if all(board[pit] == 0 for pit in p1_side) or all(board[pit] == 0 for pit in p2_side):
        
        return True
    
    return False
    

def collect_remaining_pebbles(board, p1_side, p2_side, p1_store, p2_store):
    """
        COllects remeining pebbles when one side of the board is empty
    Args:
        
        board (list): The game board represented by as a list of integers.
        Each index represents a pit with the number being the amount of pebbles
        or stones in each pit  
        
        p1_side (int): The indices of the pit's on Player 1's side (range: 0-6)
        
        p2_side (int): The indices of the pit's on Player 2's side (range: 7-13)
        
        p1_store (int): Player 1's score pit  that contains captured pebbles (index: 6)
        
        p2_store (int): Player 2's score pit  that contains captured pebbles (index: 13)
        
    Returns:
        list[int]: updated board after adding remeining pebbles to the player scores.
    """
    p1_occupied = {pit for pit in p1_side if board[pit] > 0}
    p2_occupied = {pit for pit in p2_side if board[pit] > 0}
    
    
    if not p1_occupied:
        remaining  = sum(board[pit] for pit in p2_side)
    
        for pit in p2_side:
            board[pit] = 0
        board[p2_store] += remaining 
        
        
    elif not p2_occupied:
        remaining  = sum(board[pit] for pit in p1_side)
        empty_pits = set(p1_side) - p1_occupied
        
        for pit in p1_occupied.union(empty_pits):
            board[pit] = 0
        board[p1_store] += remaining 
        
    return board


    
def Calculate_final_score(board, p1_store, p2_store):
    """ 

    Args:
    
        board (list): The game board represented by as a list of integers.
        Each index represents a pit with the number being the amount of pebbles
        or stones in each pit  
        
        p1_side (int): The indices of the pit's on Player 1's side (range: 0-6)
        
        p2_side (int): The indices of the pit's on Player 2's side (range: 7-13)

    Returns:
        tuple: A tuple containing the players and thier final scores
    """
    final_scores = {"Player 1": board[p1_store], "Player 2": board[p2_store]}
    
    # Compare the scores. The player with with higher number is the winner
    # If the scores are eqaual then the game is a draw
    if final_scores["Player 1"] > final_scores["Player 2"]:
        winner = "Player 1"
    elif final_scores["Player 2"] > final_scores["Player 1"]:
        winner = "Player 2"
    else:
        winner = "Draw"
        
    return final_scores, winner