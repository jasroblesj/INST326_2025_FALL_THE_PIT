from argparse import ArgumentParser
import sys
import random as rd

class Mancala:
    def __init__(self, p1, p2):
        self.board = [4, 4, 4, 4, 4, 4, 0, 
                      4, 4, 4, 4, 4, 4, 0] 
        self.p1 = p1
        self.p2 = p2

    def display_board(self):
        """
        Author - Akbar Sajjad
        
        Displays Mancala Board
        
        Args:
            Self
        
        Side Effects:
            Prints board display
        """
        print("\n\tPlayer 2")
        
        #p2 pits from p2s perspective
        for pits in range(12, 6, -1):
            print(f"[{self.board[pits]:2}]", end = " ")
        print()
        print(f"[{self.board[13]:2}]\t\t\t [{self.board[6]:2}]")
        
        #p1 pits from p1s perspective 
        for pits in range(0,6):
            print(f"[{self.board[pits]:2}]", end = " ")
        print("\n\tPlayer 1")


    def distribute(self, starting_pit, current_player):
        """   
        Author - Akbar Sajjad
        
        Technique claimed: Conditional expressions
    
        Distribute the stones one by one into the pits, skipping over the opponents pit
    
        Args:   
            starting pit: int - index of the chosen pit to distribute stones from 
            current_player: str - the current player ("p1" or "p2")
    
        Returns:
            last_pit: int - index of the pit where the last stone was placed
        """
        #determining the starting pit to start distribution
        if self.board[starting_pit] > 0:
            current_stonecount = self.board[starting_pit]
            self.board[starting_pit] = 0
        else:
            print("You must pick a board that has at least 1 stone and is not"\
            "yours or your opponents scoring pit")
            return None
    
        # where to begin dropping stones
        droppoint = (starting_pit + 1) % 14
 
        # skipping pits logic based on current player
        skippedpit = 13 if current_player == "p1" else 6
        
    
        #distribution iteration
        for stones in range(current_stonecount):
            while droppoint == skippedpit:
                droppoint = (droppoint + 1) % 14 
        
        #place stones
            self.board[droppoint] += 1
            last_pit = droppoint
            droppoint = (droppoint + 1) % 14 
    
        #return the last pit the stone was placed
        return last_pit
    
    def capture(self, last_pit, player):
        """
        Author - Robsan Melaku
    
        Apply the capturing aspect of Mancala.
    
        Args:
            board: ints representing stones in pits
            last_pit: index of last pit marble was placed
            player: 1 or 2
    
        Returns: updated board
        """
        #set pit and store status
        #p1 first pit is 0, p2 first pit is 7
        p1_side = range(0,6)
        p2_side = range(7,13)
    
        #p1 store is 6, p2 store would be 13
        p1_store = 6
        p2_store = 13
    
        #need to find out position of last marble using player
        #1 is player 1 and 2 is player 2
        if player == "p1":
            #my_side is the side of the current player
            my_side = p1_side
            #store is the store of the current player
            store = p1_store #would be 6 in this case
            parallel = 12 - last_pit #calc parallel side
        else: #repeat for player 2
            my_side = p2_side
            store = p2_store
            parallel = 12 - last_pit
    
        #use contains magic method to check if current pit is empty AND is on current player side
        if my_side.__contains__(last_pit) and self.board[last_pit] == 1:
        
            #initialize var to take marbles from parallel side
            take_parallel = self.board[parallel]
        
            #capture marbles from take_parallel
            self.board[store] += 1 + take_parallel #use += 1 to include player's marble
        
            #empty the board at the last pit and the parallel pit
            #marbels have been taken and added to player store
            self.board[last_pit] = 0
            self.board[parallel] = 0

        return self.board
    

    def check_turn(self, last_index, player1, player2): 
        """ Jasmin's function
        Determines if the current player gets another turn or if the turn switches.

        Args:
    
            last_index (int): the index of the pit where the last marble landed
        
            player1 (Player): the player who just had a turn
        
            player2 (Player): the player who is playing against player1

        Side effects: 
            Prints whether it is player1 or player2's turn
        """
        player_score_pit = self.get_pit_index(player1)

        #if player1 landed in their score pit, they get another turn
        if last_index == player_score_pit:
            self.set_turn(player1, True)
            self.set_turn(player2, False)
            print(f"{player1.name} gets another turn!")

        #if player1 does not land in their score pit, it is player2's turn
        else:
            self.set_turn(player1, False)
            self.set_turn(player2, True)
            print(f"{player2.name}'s turn!")
    
    def get_pit_index(self, player):
        return 6 if player is self.p1 else 13

    def set_turn(self, player, status):
        player.set_turn(status)

    def Check_game_end(self, p1_side, p2_side, p1_store, p2_store):
        """
        End game if one side of the board is empty or when one player has more than
        half the pebbles in their store.


        Args:
   
            board (list): The game board represented by as a list of integers.
            Each index represents a pit with the number being the amount of pebbles
            or stones in each pit  
       
            p1_side (int): The indices of the pit's on Player 1's side (range: 0-6)
       
            p2_side (int): The indices of the pit's on Player 2's side (range: 7-13)
       
            p1_store (int): Player 1's score pit  that contains captured pebbles (index: 6)
       
            p2_store (int): Player 2's score pit  that contains captured pebbles (index: 13)


        Returns:
   
            Bool: True if the game has ended, False if the game has not ended.
        """
        total_stones = sum(self.board)
   
        if self.board[p1_store] > total_stones // 2 or self.board[p2_store] > total_stones // 2:
            return True
   
   
        if all(self.board[pit] == 0 for pit in p1_side) or all(self.board[pit] == 0 for pit in p2_side):
       
            return True
   
        return False

    def collect_remaining_pebbles(self, p1_side, p2_side, p1_store, p2_store):
        """
            COllects remeining pebbles when one side of the board is empty
        Args:
       
            board (list): The game board represented by as a list of integers.
            Each index represents a pit with the number being the amount of pebbles
            or stones in each pit  
       
            p1_side (int): The indices of the pit's on Player 1's side (range: 0-6)
       
            p2_side (int): The indices of the pit's on Player 2's side (range: 7-13)
       
            p1_store (int): Player 1's score pit  that contains captured pebbles (index: 6)
       
            p2_store (int): Player 2's score pit  that contains captured pebbles (index: 13)
       
        Returns:
            list[int]: updated board after adding remeining pebbles to the player scores.
        """
        p1_occupied = {pit for pit in p1_side if self.board[pit] > 0}
        p2_occupied = {pit for pit in p2_side if self.board[pit] > 0}
   
   
        if not p1_occupied:
            remaining  = sum(self.board[pit] for pit in p2_side)
   
            for pit in p2_side:
                self.board[pit] = 0
            self.board[p2_store] += remaining
       
       
        elif not p2_occupied:
            remaining  = sum(self.board[pit] for pit in p1_side)
            empty_pits = set(p1_side) - p1_occupied
       
            for pit in p1_occupied.union(empty_pits):
                self.board[pit] = 0
            self.board[p1_store] += remaining
       
        return self.board

    def Calculate_final_score(self, p1_store, p2_store):
        """
            calculate the player final score

        Args:
   
            board (list): The game board represented by as a list of integers.
            Each index represents a pit with the number being the amount of pebbles
            or stones in each pit  
       
            p1_side (int): The indices of the pit's on Player 1's side (range: 0-6)
       
            p2_side (int): The indices of the pit's on Player 2's side (range: 7-13)


        Returns:
            tuple: A tuple containing the players and thier final scores
        """
        final_scores = {"Player 1": self.board[p1_store], "Player 2": self.board[p2_store]}
   
        # Compare the scores. The player with with higher number is the winner
        # If the scores are eqaual then the game is a draw
        if final_scores["Player 1"] > final_scores["Player 2"]:
            winner = "Player 1"
        elif final_scores["Player 2"] > final_scores["Player 1"]:
            winner = "Player 2"
        else:
            winner = "Draw"
       
        return final_scores, winner
    
    
    def check_moves(self, player):
        """
        Author - Robsan Melaku

            Find which pits the given player can currently move from.

        Args:
            board: list of ints representing stones in each pit
            player: 1 or 2

        Returns:
            A set of pit indexes that contain stones that belong to the player.
        """
    
        #set pit and store status
        #p1 first pit is 0, p2 first pit is 7
        p1_side = range(0,6)
        p2_side = range(7,13)
    
        #set my side to current player side
        if player == "p1":
            my_side = set(p1_side)
        else:
            my_side = set(p2_side)
    
        #make set of non empty pits
        non_empty = {i for i in range(len(self.board)) if self.board[i] > 0}

        #find pits that belong to player and are not empty
        move = my_side & non_empty

        return move    
    
    #game loop 
    def run_game(self):
        """
        Author: Akbar Sajjad
        
        Technique claimed: Composition of two custom classes
        
        Runs the Mancala game loop, brings all functions together
        
        Args: 
            self - Mancala game instance
            
        """
        
        #starting player 
        starting_player = rd.choice([self.p1, self.p2])
        starting_player.set_turn(True)
        
        other_player = self.p2 if starting_player is self.p1 else self.p1
        other_player.set_turn(False)
        print(f"{starting_player.name} goes first")
        
        #game loop
        while True:
            starting_player = self.p1 if self.p1._my_turn else self.p2
            other_player = self.p2 if starting_player is self.p1 else self.p1
            
            #the pits the player is allowed to pick from (the ones on their side)            
            #begin board display and choice
            self.display_board()
            print(f"\n{starting_player.name}, your turn\n")
            
            determine_player = "p1" if starting_player is self.p1 else "p2"
            allowed_moves = self.check_moves(determine_player)
            print(f"Your allowed pits: {sorted(allowed_moves)}")
            
            while True:
                try:
                    pit_choice = int(input("Choose your pit index: "))
                except ValueError:
                    print("Pick a valid choice please")
                    continue
                if pit_choice not in allowed_moves:
                    print("You cannot choose this pit, choose one of yours")
                    continue
                #empty pit
                if self.board[pit_choice] == 0:
                    print("This is an empty pit, pick one that has some stones")
                    continue
                break
            
            #distribution
            last_pit = self.distribute(pit_choice, determine_player)
            
            #capture
            self.capture(last_pit, determine_player)
            
            #check turn
            self.check_turn(last_pit, starting_player, other_player)
            
            #ending the game lgoic
            if self.Check_game_end(range(0,6), range(7,13),6,13):
                print(f"\nThe game is over! collecting the remaining stones...")
                self.collect_remaining_pebbles(range(0,6), range(7,13), 6,13)
                final_scores, winner = self.Calculate_final_score(6,13)
                print("\nFinal Scores:")
                print(final_scores)
                print(f"The winner is: {winner}\n")
                self.display_board()
                break


class Player:
    def __init__(self, name):
        self.name = name
        self._my_turn = False
        
    def set_turn(self, status):
        self._my_turn = status

        
def parse_args(arglist):
    """ Parse command-line arguments.
        
    Allow two optional arguments:
        -s, --stones: number of stones per pit (default:4)
        -n, --names: one or two player names
    
    Args:
        arglist (list of str): arguments from the command line.
    
    Returns:
        namespace: the parsed arguments, as a namespace.
    """
    parser = ArgumentParser()
    parser.add_argument("-s", "--stones", type = int, default=4,
                        help="number of stones per pit (default: 4)")
    parser.add_argument("-n", "--names", nargs = "*", help="player names")
    return parser.parse_args(arglist)
   

def main(stones, names):
    """
    Author - Akbar Sajjad
    
    Technique claimed: Composition of two custom classes
    
    Initiate a Mancala game
    
    Args:
        stones (int): # of stones that each pit starts with default value is 4
        names (list): list containing two player names, default are "Player 1/2"
    
    Side Effects:
        Prints game layout
        Starts game loop
        modifies game as it is played
          
    """
    stones = 4
    if not names:
        p1_name = "Player 1"
        p2_name = "Player 2"
    elif len(names) == 1:
        p1_name = names[0]
        p2_name = "Player 2"
    else:
        p1_name, p2_name = names[0], names[1]
    
    #player and game instance
    p1 = Player(p1_name)
    p2 = Player(p2_name)
    
    game = Mancala(p1, p2)
    
    #run the game 
    print(f"Lets Play Mancala\n")
    print(f"{p1_name} vs. {p2_name}")
    print(f"\nEach pit starts with {stones} stones\n")
    
    game.run_game()
    

if __name__ == "__main__":
    args = parse_args(sys.argv[1:])
    main(args.stones, args.names)
