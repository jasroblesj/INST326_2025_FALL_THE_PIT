from argparse import ArgumentParser
import sys

class Mancala:
    def __init__(self, p1, p2):
        self.board = [4, 4, 4, 4, 4, 4, 0, 
                      4, 4, 4, 4, 4, 4, 0] 
        self.p1 = p1
        self.p2 = p2

    def display_board(self):
        """
        Author - Akbar Sajjad 
        
        Displays Mancala Board
        
        Args:
            Self
        """
        print("\n\tPlayer 2")
        
        #p2 pits from p2s perspective
        for pits in range(12, 6, -1):
            print(f"[{self.board[pits]:2}]", end = " ")
        print()
        print(f"[{self.board[13]:2}]\t\t\t [{self.board[6]:2}]")
        
        #p1 pits from p1s perspective 
        for pits in range(0,6):
            print(f"[{self.board[pits]:2}]", end = " ")
        print("\n\tPlayer 1")


    def distribute(self, starting_pit, current_player):
        """   
        Author - Akbar Sajjad
    
        Distribute the stones one by one into the pits, skipping over the opponents pit
    
        Arguments:
            p1 pits - indices 0-5 | p1storage - index 6
            p2 pits - indices 7-12 | p1storage - index 13    
            starting pit: int - index of the chosen pit to distribute stones from 
            current_player: str - the current player ("p1" or "p2")
    
        Returns:
            last_pit: int - index of the pit where the last stone was placed
        """
    #determining the starting pit to start distribution
        if self.board[starting_pit] > 0:
            current_stonecount = self.board[starting_pit]
            self.board[starting_pit] = 0
        else:
            print("You must pick a board that has at least 1 stone and is not"\
            "yours or your opponents scoring pit")
            return None
    
    # where to begin dropping stones
        droppoint = (starting_pit + 1) % 14
 
    # skipping pits logic based on current player
        skippedpit = 13 if current_player == "p1" else 6
        
    
    #distribution iteration
        for stones in range(current_stonecount):
            while droppoint == skippedpit:
                droppoint = (droppoint + 1) % 14 
        
        #place stones
            self.board[droppoint] += 1
            last_pit = droppoint
            droppoint = (droppoint + 1) % 14 
    
    #return the last pit the stone was placed
        return last_pit


def capture(board, last_pit, player):
    """Apply the capturing aspect of Mancala.
    
    board: ints representing stones in pits
    last_pit: index of last pit marble was placed
    player: 1 or 2
    
    Returns: updated board
    """
    #set pit and store status
    #p1 first pit is 0, p2 first pit is 7
    p1_side = range(0,6)
    p2_side = range(7,13)
    
    #p1 store is 6, p2 store would be 13
    p1_store = 6
    p2_store = 13
    
    #need to find out position of last marble using player
    #1 is player 1 and 2 is player 2
    if player == 1:
        #my_side is the side of the current player
        my_side = p1_side
        #store is the store of the current player
        store = p1_store #would be 6 in this case
        parallel = 12 - last_pit #calc parallel side
    else: #repeat for player 2
        my_side = p2_side
        store = p2_store
        parallel = 12 - last_pit
    
    #check if current pit is empty AND is on current player side
    if last_pit in my_side and board[last_pit] == 1:
        
        #initialize var to take marbles from parallel side
        take_parallel = board[parallel]
        
        #capture marbles from take_parallel
        board[store] += 1 + take_parallel #use += 1 to include player's marble
        
        #empty the board at the last pit and the parallel pit
        #marbels have been taken and added to player store
        board[last_pit] = 0
        board[parallel] = 0

    return board


def check_turn(last_index, player1, player2): 
    """ Jasmin's function
    Determines if the current player gets another turn or if the turn switches.

    Args:
        last_index (int): the index of the pit where the last marble landed
        player1 (Player): the player who just had a turn
        player2 (Player): the player who is playing against player1

    Side effects: 
        - Prints whether it is player1 or player2's turn
    """
    player_score_pit = get_pit_index(player1)

    #if player1 landed in their score pit, they get another turn
    if last_index == player_score_pit:
        set_turn(player1, True)
        set_turn(player2, False)
        print(f"{player1.name} gets another turn!")

    #if player1 does not land in their score pit, it is player2's turn
    else:
        set_turn(player1, False)
        set_turn(player2, True)
        print(f"{player2.name}'s turn!")

def get_pit_index(player):
    return 6 if player.name == "Player 1" else 13

def set_turn(player, status):
    player.set_turn(status)

class Player:
    def __init__(self, name):
        self.name = name
        self._my_turn = False
        
    def set_turn(self, status):
        self._my_turn = status
        
def parse_args(arglist):
    """ Parse command-line arguments.
        
    Allow two optional arguments:
        -s, --stones: number of stones per pit (default:4)
        -n, --names: one or two player names
    
    Args:
        arglist (list of str): arguments from the command line.
    
    Returns:
        namespace: the parsed arguments, as a namespace.
    """
    parser = ArgumentParser()
    parser.add_argument("-s", "--stones", type = int, default=4,
                        help="number of stones per pit (default: 4)")
    parser.add_argument("-n", "--names", nargs = "*", help="player names")
    return parser.parse_args(arglist)

def end_game_and_final_score(board, p1_side, p2_side, p1_store, p2_store): #Theo's Function
    """Checks the pebbles in each pit and places remaining pebbles in a player's,
    then compares score to return a winner or draw if the scores are equal


    Args:
        board (list of ints): A representation of the board using list of numebrs        
        p1_side (list): A list of numbers representing Player 1's side of the board
        p2_side (list): A list of numbers representing Player 2's side of the board
        p1_store (int): The number of pebbles Player 1 has
        p2_store (int): The number of pebbles Player 2 has

    Returns:
        final_scores (Dict): The players and their scores
        game_end (Bool): Whether the game has eneded or not (True if game has ended. False If not)
        winner (Str): The name of the winner as a string
        board (list): An updated board after remeining pebbles have been added
        
    """
    game_end = False 
    final_scores = {} # Creates an empty dictonary to store the player's score{Player:Score}
    
    # For each pit on player 1's side check to see if all the pits are empty 
    # If they are then the game should end
    if all(board[pit] == 0 for pit in p1_side):
        game_end = True
            
        # For each pit on Player 2's side add all the leftover the pebbles 
        remaining_pebbles = sum(board[pit] for pit in p2_side)
                
        # Remove the pebbles from the pits after the remainder is stored
        # Add the total leftover pebbles to the Player 2's store
        for pit in p2_side: 
            board[pit] = 0
        board[p2_store] += remaining_pebbles
                
    if all(board[pit] == 0 for pit in p2_side):
        game_end = True
        remaining_pebbles = sum(board[pit] for pit in p1_side)
        for pit in p1_side: 
            board[pit] = 0 #Removes pebbles after the remainder stored
        board[p1_store] += remaining_pebbles
                
    # Create players as dictionary keys with the scores as their values
    final_scores["Player 1"], final_scores["Player 2"] = board[p1_store], board[p2_store]
    
    # Compare the scores. The player with with higher number is the winner
    # If the scores are eqaual then the game is a draw
    if final_scores["Player 1"] > final_scores["Player 2"]:
        winner = "Player 1"
    elif final_scores["Player 2"] > final_scores["Player 1"]:
        winner = "Player 2"
    else:
        winner = "Draw"
        
    return final_scores, winner, game_end, board
